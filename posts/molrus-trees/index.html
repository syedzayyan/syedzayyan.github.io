<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> Driving into a tree, in a Rusty car </title><link href=/menu_icon/profile_pic.png rel=icon type=image/png><link href="https://syedzayyan.com/ atom.xml" title="Syed Zayyan Masud" rel=alternate type=application/atom+xml><link href=https://syedzayyan.com/main.css media=screen rel=stylesheet><meta content="A personal portfolio/blog website of Syed Zayyan Masud" name=description><meta content="A personal portfolio/blog website of Syed Zayyan Masud" name=description><meta content="index, nofollow" name=robots><meta content="Syed Zayyan Masud" property=og:title><meta content=article property=og:type><meta content=/menu_icon/profile_pic.png property=og:image><meta content=/menu_icon/profile_pic.png name=twitter:card><meta content=https://syedzayyan.com/posts/molrus-trees/ property=og:url><meta content="A personal portfolio/blog website of Syed Zayyan Masud" property=og:description><meta content="Syed Zayyan Masud" property=og:site_name><meta content="default-src 'self' ws://127.0.0.1:1024/; img-src 'self' https://*; script-src 'self'; style-src 'self'; font-src 'self'" http-equiv=Content-Security-Policy><body><header><div class=navbar><div class="nav-title nav-navs"><a class="nav-links home-title" href=https://syedzayyan.com>Syed Zayyan Masud</a></div><nav class="nav-title nav-navs"><a class=nav-links href=/projects> <img alt=Projects height=15 src=/menu_icon/projects.png width=15> Projects</a><a class=nav-links href=/about> <img alt=About height=15 src=/menu_icon/profile_pic.png width=15> About</a></nav><nav class="socials nav-navs"><label class=theme-switcher for=themeswitch><div class=background></div> <input id=themeswitch type=checkbox> <div class=switch><img alt="theme switch to dark" class=moon src=/menu_icon/moon.png><img alt="theme switch to light" class=sun src=/menu_icon/sun.png></div></label></nav></div></header><div class=content><main><article><div class=title><h2>Driving into a tree, in a Rusty car</h2><div class=meta>Posted on <time>2024-07-08</time><div class=post-tags><nav class="nav tags">üè∑: <a href=https://syedzayyan.com/tags/rants/>rants</a> ¬† <a href=https://syedzayyan.com/tags/rust/>rust</a> ¬† <a href=https://syedzayyan.com/tags/code/>code</a> ¬† <a href=https://syedzayyan.com/tags/discussion/>discussion</a> ¬†</nav></div> ||<span> 3 minute read</span></div></div><section class=body><p>I like Rust, at least I want to on most days, but implementing trees in Rust is interesting. First of all, why do I even need a tree. I am writing a cheminformatics toolkit and am implementing a SMARTS parser. I am going the ubiquitous route of building the abstract syntax tree (AST) to match a molecule structure. Easy! (Basically I am 'getting inspired' from <a href=https://github.com/openbabel/openbabel/blob/master/include/openbabel/parsmart.h>OpenBabel's SMARTs Parser </a>, <a href=https://github.com/cdk/cdk/blob/38e7a206c51a623667530276a2bb07c9c5f4f44d/tool/smarts/src/main/java/org/openscience/cdk/smarts/Smarts.java>CDK</a> because I am an impostor amongst real programmers) But, Rust's strict ownership rules make it difficult to have tree structures implemented in the way it would be written in a better language like C/C++. I will shuffle between hating and loving Rust so hold your pitchforks till the end. So, in C++ a <code>BondExpr</code> will be defined as something like:<pre class="language-C++ z-code" data-lang=C++><code class=language-C++ data-lang=C++><span class="z-source z-c++">  <span class="z-storage z-type z-c++">typedef</span> <span class="z-storage z-type z-c">union</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">_BondExpr</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">{</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">
    <span class="z-storage z-type z-c">int</span> type<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-storage z-type z-c">struct</span>
    <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
      <span class="z-storage z-type z-c">int</span> type<span class="z-punctuation z-terminator z-c++">;</span>
      <span class="z-storage z-type z-c">union</span> _BondExpr <span class="z-keyword z-operator z-c">*</span>arg<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
      mon<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-storage z-type z-c">struct</span>
    <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
      <span class="z-storage z-type z-c">int</span> type<span class="z-punctuation z-terminator z-c++">;</span>
      <span class="z-storage z-type z-c">union</span> _BondExpr <span class="z-keyword z-operator z-c">*</span>lft<span class="z-punctuation z-terminator z-c++">;</span>
      <span class="z-storage z-type z-c">union</span> _BondExpr <span class="z-keyword z-operator z-c">*</span>rgt<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-punctuation z-section z-block z-end z-c++">}</span></span>
      bin<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">}</span></span></span> <span class="z-entity z-name z-type z-typedef z-c++">BondExpr</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><p>Unions don't exist in Rust, I mean they do but you need <code>unsafe</code>, and at that point might as well use C and shoot yourself in the foot. So we can use the better thing: <code>enum</code>!<pre class="language-Rust z-code" data-lang=Rust><code class=language-Rust data-lang=Rust><span class="z-source z-rust"><span class="z-meta z-enum z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-enum z-rust">enum</span> <span class="z-entity z-name z-enum z-rust">BondExpr</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
	Monadic <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
		bond_type<span class="z-punctuation z-separator z-rust">:</span> BondTypes<span class="z-punctuation z-separator z-rust">,</span>	
		arg<span class="z-punctuation z-separator z-rust">:</span> BondExpr<span class="z-punctuation z-separator z-rust">,</span>
	</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-separator z-rust">,</span>
	Binary <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
		bond_type<span class="z-punctuation z-separator z-rust">:</span> BondTypes<span class="z-punctuation z-separator z-rust">,</span>
		left<span class="z-punctuation z-separator z-rust">:</span> BondExpr<span class="z-punctuation z-separator z-rust">,</span>
		right<span class="z-punctuation z-separator z-rust">:</span> BondExpr<span class="z-punctuation z-separator z-rust">,</span>
	</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Rust being Rust, you can't have that. We get an error:<p><code>recursive type BondExpr has infinite size</code><p>I mean that makes sense but how do I just point to a variable that's allocated somewhere? I promise I'll clean it! You don't. In Rust you get a <code>Box</code>, because it thinks I can't take care of myself. I mean sure, I can't, but show some faith. Using boxes, we reach something that looks ugly, but something that works:<pre class="language-Rust z-code" data-lang=Rust><code class=language-Rust data-lang=Rust><span class="z-source z-rust"><span class="z-meta z-enum z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-enum z-rust">enum</span> <span class="z-entity z-name z-enum z-rust">BondExpr</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    Monadic <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
        bond_type<span class="z-punctuation z-separator z-rust">:</span> BondTypes<span class="z-punctuation z-separator z-rust">,</span>
        arg<span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Box</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>BondExpr<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-separator z-rust">,</span>
    Binary <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
        bond_type<span class="z-punctuation z-separator z-rust">:</span> BondTypes<span class="z-punctuation z-separator z-rust">,</span>
        left<span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Box</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>BondExpr<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
        right<span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Box</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>BondExpr<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Now you might go, but why can't you just use a flat vector and store indices? Sure, great idea, except I am doing that already.<pre class="language-Rust z-code" data-lang=Rust><code class=language-Rust data-lang=Rust><span class="z-source z-rust"><span class="z-meta z-enum z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-enum z-rust">enum</span> <span class="z-entity z-name z-enum z-rust">NodeData</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    Atom<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>AtomSpec</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
    Bond<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>BondSpec</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
    Unknown<span class="z-punctuation z-separator z-rust">,</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
<span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">TreeNode</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">op_code</span><span class="z-punctuation z-separator z-type z-rust">:</span> OpCode,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">data</span><span class="z-punctuation z-separator z-type z-rust">:</span> NodeData,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">parent</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">usize</span>,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">visit</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">bool</span>,
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
<span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">SmartsPattern</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">nodes</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Vec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>TreeNode<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">root</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">usize</span>,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">smarts_string</span><span class="z-punctuation z-separator z-type z-rust">:</span> String,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">chirality</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">bool</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>But I don't want to make a bond node if I can get away with just pointing to a <code>BondExpr</code>. Then you reach the problem where Bonds have a source and destination and you can often infer that the next node after the bond will be an atom node. Still, if you have an expression hogging up your clean vector, now you have the problem of going back to fix your destination in the <code>BondSpec</code>. Now we could have a second vector for storing these second layer of expressions, but when setting the indices it becomes a nightmare to read the code. Sure we can make our types and do a casting but eh.<p>So yeah. Boxes and Options are with a bunch of unwraps when matching the molecule. I am not complaining, it's just what it is in Rust, or if you have a better idea, please by any means contribute to <a href=https://github.com/syedzayyan/molrus>molrus</a>.</section></article></main></div><footer><section><nav><a class="nav-links social" rel="noopener noreferrer" href=https://youtube.com/@zayyanmasud target=_blank> <img alt=youtube src=/social_icons/youtube.svg title=youtube> </a><a class="nav-links social" rel="noopener noreferrer" href=https://github.com/syedzayyan/ target=_blank> <img alt=github src=/social_icons/github.svg title=github> </a></nav><nav><span classname=desktop-only>This blog is powered by <a rel="noopener noreferrer" href=https://getzola.org/ target=_blank>Zola</a> with theme by <a rel="noopener noreferrer" href=https://syedzayyan.com/ target=_blank>SZM</a></span></nav></section><script src=https://syedzayyan.com/js/main.js></script></footer>